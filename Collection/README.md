# Collection Framework
데이터 군을 저장하는 클래스들을 표준화한 설계

![Alt text](https://i.imgur.com/JmO4zX2.png")

> 컬렉션 프레임웍의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있으며,<br>
이름만으로도 클래스의 특징을 쉽게 알 수 있도록 되어있다. <br>
그러나 Vector, Stack, Hashtable, Properties와 같은 클래스들은 컬렉션 프레임웤이만들어지기 전<br>
부터 존재하던 것이기 때문에 컬렉션 프레임웤의 명명법을 따르지 않는다.<br>
Vector나 HashTable과 같은 기존의 컬렉션 클래스들은 호환을 위해 남겨두었지만<br>
가능하면 사용하지 않는 것이 좋다. 그 대신 새로 추가된 ArrayList와 HashMap을 사용하자.
## 1. LIST
List인터페이스는 `중복을 허용` 하면서 `저장순서가 유지`된다.<br>
![Alt text](https://t1.daumcdn.net/cfile/tistory/996AF8475BB861F210)
### 1.1. ArrayList
- **크기에 제한이 있다. (array)**

- **읽기(접근시간)이 빠르다. (get)**

- **순차적으로 추가/삭제하는 경우 빠르다. (add/remove)**
  - 충분한 저장공간과 역순으로 데이터를 삭제하는 경우<br>
  즉, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동하지 않도록 해야한다.
- 예시 : stack (컬렉션 프레임웍 이전부터 존재하던 것이기에 사실상 구현클래스는 Vector)

### 1.2. LinkedList
- **크기에 제한이 없다. (list)**

- **읽기(접근시간이)이 느리다. (get)**
  - 데이터가 많을 수록 접근성이 떨어진다.<br>
  그 이유는, `배열`은 각 요소들이 연속적으로 메모리상에 존재하기 때문에 간단한 계산만으로도 원하는 값을<br>
  곧바로 얻을 수 있다.<br>
  하지만 `리스트`는 각 요소들이 불연속적으로 메모리상에 존재하기 때문에 처음부터 n번째 데이터까지<br>
  차례대로 따라가야만 원하는 값을 얻을 수 있다.
 
- **중간에 데이터를 추가/삭제하는 경우 빠르다 (add/remove)**
- 예시 : Queue
> LinkedList 클래스는 이름과 달리 '링크드 리스트'가 아닌 '더블 링크드 리스트'로 구현되어있다.<br>
>> 링크드리스트는 이동이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다.

>> 더블 링크드 리스트드는 이동이 양방향이기 때문에 다음요소, 이전요소에 대한 접근이 가능하다.


#### 출처
- Java의 정석 - 남궁성

